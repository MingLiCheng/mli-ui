---
title: 'url 输入到解析的过程'
---

# 从浏览器地址栏输入url到请求返回发生了什么

### 1. 浏览器输入url
- 浏览器对url进行解析，因为url在传送前需要进行编码，一些特殊符号需要进行编码防止出现歧义
- 由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式 
- URL 编码使用 "%" 其后跟随两位的十六进制数来替换非 ASCII 字符
- javascript url编码方法 encodeURI encodeURIComponent
  - encodeURI: 着眼于对整个URL进行编码，特殊含义的符号"; / ? : @ & = + $ , #“不进行编码
  - encodeURIComponent: 对URL的组成部分进行个别编码，所以”; / ? : @ & = + $ , #"在这里是可以进行编码
  - 后者比前者的编码范围更广泛一点， 一般对包含http://的链接使用 encodeURI ， 对路径中包含参数的链接使用encodeURIComponent

### 2. DNS解析
- 域名解析 根据域名寻找对应服务的IP
- DNS解析过程
  - 1. 查询本地hosts文件
  - 2. 查询本地DNS服务器来解析该域名判断是否有缓存
  - 3. dns查询有两种模式，一种是转发模式，一种是非转发模式
  - 4. 非转发模式：没有的话就去找根DNS服务器(全球13台，固定ip地址)，然后判断.com域名是哪个服务器管理，如果无法解析，就查找.baidu.com服务器是否能解析，直到查到www.baidu.com的IP地址
  - 5. 转发模式：如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环
  - 6. DNS服务器是有缓存的向前缓存
- 前端DNS优化

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
```

### 3. TCP连接   （核心观点 "让我知道 我发给你的东西 你收到了"）
 
  - 三次握手
    - A-->B: 发送请求码(SYN)请求连接B 当前seq = x
    - B-->A: 发送确认码(ACK)确认收到A的请求，发送SYN请求和A连接 当前seq=y
    - A-->B: 发送确认码(ACK)确认收到B的请求，发送seq x + 1, y+1
    - 至此连接已经建立： A：知道B已经确认，  B知道A已经确认
  - 四次挥手 
    - A-->B: 发送断开码(FIN)给B,请求断开连接
    - B-->A: 发送确认码(ACK)  让A知道B已经收到了请求
    - B-->A: 发送断开码(FIN) 
    - A-->B: 发送确认码(ACK) 让B知道A已经收到请求
    - 至此 双方都知道对方已经确认可以断开了 

1. 为什么建立连接需要三次 而 断开连接需要四次 <br>

> 建立连接时B在回复A的确认(ACK)时可以直接携带上请求连接确认码(SYN) 请求和A建立连接 <br>
> 而断开时B回复确认码(ACK)时无法保证可以直接携带上断开码(FIN) 因为B可能还在处理A发送的信息,所以B需要单独发送FIN来告诉A可以断开连接，A也需要再次回复B告诉B，A已经收到了这个断开 请求

2. 为什么两次握手不能建立连接<br>

> 两次握手意味着 有一方没有确认对方是否收到自己发送信息，这时候它直接发送信息给对方此时可能会产生死锁， 重复发送相同的报文

3. 从网卡把数据包传输出去到服务器发生了什么, ISO模型<br>

> 应用层 -----> 数据链路层：  是一个不断封包的过程， 每一层 都会加上自己的协调头<br>
> 数据链路层 -----> 应用层：  另外一端接收到数据包后， 进行不断的拆包过程 最后把数据取出<br>
>
> (应用层) `应用层` `表示层` `会话层` ---> (传输层) `传输层`  ---> (网际层) `网络层` ---> (网络接口层) `数据链路层` --->(硬件层) `物理层`<br>

### 4. 请求HTML文件
> TCP 成功握手后就可以请求HTML文件了，请求HTML首先会遇到缓存问题，浏览器会判断缓存

- 首先进行`强缓存`判断 
  - cache-control的优先级最高， cache-control:no-cache 直接进入一个协商缓存
  - cache-control:max-age=xxx, 比较当前时间和上次缓存的时间差， 没超过max-age 则命中强缓存
  - 没有cache-control 取值 expires 的值 
- 没命中强缓存会进入`协商缓存`
  -  浏览器向服务器发送header中带有 If-None-Match 和 If-Modified-Since的请求，服务器会比较Etag 如果相同命中协商缓存，返回304，不一致的话返回新文件和Etag
  -  If-Modified-Since 的值和服务端获取的文件最近改动时间相同 则命中协商缓存返回304;不一致返回新的的las-modified和文件
- `启发式缓存` 如果没有缓存信息， 即响应中不包含其他有关缓存的限制 则会使用启发式计算新鲜度寿命
  - 通常会根据响应头中的2个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间
  - Date 减去 Last-Modified 值的 10% 作为缓存时间
  - Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间
  - response_is_fresh =  max(0,（Date -  Last-Modified)) % 10


> 命中强缓存后 会先从内存中查询当前文件查询不到的话再去硬盘中查询最后都没有的话请求网络 from disk cache和from memory cache


### 5. 解析HTML文件

  



接着回答，我说返回html之后，会解析html,这部分知识我提前准备过，但是答的不是很详细，大概意思就是cssom + domTree = html,然后布局和绘制
构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；
构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；
执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；
渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。
布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；
绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；

接着面试官问我一些页面渲染层的一些优化手段，大概如下：
页面渲染优化

HTML文档结构层次尽量少，最好不深于六层；
脚本尽量后放，放在前即可；
少量首屏样式内联放在标签内；
样式结构层次尽量简单；
在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；
减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；
动画尽量使用在绝对定位或固定定位的元素上；
隐藏在屏幕外，或在页面滚动时，尽量停止动画；
尽量缓存DOM查找，查找器尽量简洁；
涉及多域名的网站，可以开启域名预解析
最后面试官问我，如何诊断页面渲染时各个性能指标，我大概说了，通过chrome浏览器的工具，比如看网络请求情况的network，还有看页面渲染情况的perfermance，以后有机会自己总结一篇。